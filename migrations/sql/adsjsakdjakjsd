-- UP.sql

-- teams
CREATE TABLE teams IF NOT EXISTS (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL UNIQUE
);

-- users
CREATE TABLE users IF NOT EXISTS (
    id SERIAL PRIMARY KEY,
    uuid UUID NOT NULL UNIQUE,
    username VARCHAR(20),
    team_id INT,
    is_active BOOLEAN,
    -- CONSTRAINT fk_users_team
    --     FOREIGN KEY (team_id) REFERENCES teams(id)
);


-- Вот это крч прикол, как бы чтобы не делать енам, но походу это только сильное усложнение
-- pr_statuses
CREATE TABLE pr_statuses IF NOT EXISTS (
    id SERIAL PRIMARY KEY,
    status TEXT UNIQUE
);

-- pull_requests
CREATE TABLE pull_requests IF NOT EXISTS (
    id SERIAL PRIMARY KEY,
    uuid UUID NOT NULL UNIQUE,
    name VARCHAR(20),
    author_id INT,
    status TEXT, -- вот тут вообще хз enum юзать или отдельную таблицу или договариваться что int = enum
    assigned_reviewers INT,
    created_at TIMESTAMP,
    merged_at TIMESTAMP,
    -- CONSTRAINT fk_pr_author
    --     FOREIGN KEY (author_id) REFERENCES users(id),
    -- CONSTRAINT fk_pr_status
    --     FOREIGN KEY (status) REFERENCES pr_statuses(status)
);

-- assigned_users_for_pull_requests
CREATE TABLE assigned_users_for_pull_requests IF NOT EXISTS (
    user_id INT,
    pull_request_id INT,
    -- CONSTRAINT fk_assigned_user
    --     FOREIGN KEY (user_id) REFERENCES users(id),
    -- CONSTRAINT fk_assigned_pr
    --     FOREIGN KEY (pull_request_id) REFERENCES pull_requests(id)
);

-- Индексы я ещё пересмотрю потом по необходимости для запросов их сделаю
-- CREATE INDEX idx_users_team_id ON users(team_id);
-- CREATE INDEX idx_pull_requests_author_id ON pull_requests(author_id);
-- CREATE INDEX idx_pull_requests_status ON pull_requests(status);
-- CREATE INDEX idx_assigned_user ON assigned_users_for_pull_requests(user_id);
-- CREATE INDEX idx_assigned_pr ON assigned_users_for_pull_requests(pull_request_id);

-- =========================================================
--  DOWN.sql
DROP TABLE IF EXISTS assigned_users_for_pull_requests;
DROP TABLE IF EXISTS pull_requests;
DROP TABLE IF EXISTS pr_statuses;
DROP TABLE IF EXISTS users;
DROP TABLE IF EXISTS teams;

-- =========================================================
-- Запросы

-- 1. /team/add // Создать команду с участниками (создаёт/обновляет пользователей)
BEGIN;

-- Добавляем команду (если ещё нет)
WITH ins AS (
    INSERT INTO teams (name)
    VALUES ($teamName)
    ON CONFLICT (name) DO NOTHING
    RETURNING id
)
SELECT id FROM ins;

-- Если команда существует (смотрим по колву строк в результате) → ROLLBACK 

-- Получаем существующих пользователей (лок строк по FOR UPDATE)
SELECT id, uuid
FROM users
WHERE uuid = ANY($uuids)
FOR UPDATE;

-- Вставка новых пользователей (для тех uuid, которых нет)
INSERT INTO users (uuid, username, team_id, is_active)
SELECT u.uuid, u.username, $teamId, u.is_active
FROM UNNEST($uuids, $names, $isActives) AS u(uuid, username, is_active)
WHERE NOT EXISTS (
    SELECT 1 FROM users WHERE users.uuid = u.uuid
);

-- Обновление существующих пользователей, по uuids полученным ранее
UPDATE users AS u
SET username = d.username,
    team_id = $teamId,
    is_active = d.is_active
FROM (
    SELECT * FROM UNNEST($uuids, $names, $isActives) AS d(uuid, username, is_active)
) AS d
WHERE u.uuid = d.uuid;

COMMIT;



-- 2. /team/get // Получить команду с участниками
SELECT
    name AS team_name,
    uuid AS user_id,
    name AS user_name,
    is_active AS is_active
FROM teams AS t
    INNER JOIN
        users
    ON
        t.id = u.team_id
WHERE
    t.name = $1;


-- 3. /users/setIsActive // Установить флаг активности пользователя
UPDATE users
SET is_active = $2
WHERE uuid = $1;


-- 4. /users/getReview // Получить PR'ы, где пользователь назначен ревьювером
SELECT
    u.uuid AS user_id,
    pr.uuid AS pr_id,
    pr.name AS pr_name,
    pr.author_id AS author_id,
    -- s.status AS status // вопрос с полем какое юзать в таблице
FROM users AS u
    INNER JOIN assigned_users_for_pull_requests AS aufpr ON u.id = aufpr.user_id
    INNER JOIN pull_requests AS pr ON pr.id = aufpr.id
    -- LEFT JOIN statuses AS s ON pr.status = s.id
WHERE
    u.uuid = $1
    -- AND pr.status == open??????


-- 5. /pullRequest/create // Создать PR и автоматически назначить до 2 ревьюверов из команды автора
BEGIN;

SELECT 
    array_agg(u.uuid) AS active_users
FROM users AS u
    INNER JOIN teams AS t ON t.id = u.team_id // айди команды по автору пра
WHERE u.is_active = TRUE
    AND 

-- получив список пров, сервис выбирает 2х участников для проверки пра (всё это время юзеры команды локнуты)


INSERT -- новый пр


-- 6. /pullRequest/merge Пометить PR как MERGED (идемпотентная операция)


-- 7. /pullRequest/reassign Переназначить конкретного ревьювера на другого из его команды


COMMIT;


------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------

///
// // Use DBML to define your database structure
// // Docs: https://dbml.dbdiagram.io/docs

// Table members {
//   id serial pk
//   uuid uuid [not null]
//   name varchar(20)
//   team_id int
//   is_active bool [default: true]
// }

// Table teams {
//   id serial pk
//   name varchar(20)
// }

// // Table teams_members {
// //   team_id int [not null]
// //   member_id int [not null]
// // }

// // Ref teams_members: teams.id < teams_members.team_id
// // Ref members_teams: members.id < teams_members.member_id

// Ref members_teams: members.id > teams.id


// Table pull_requests {
//   id serial pk
//   uuid uuid [not null]
//   name varchar(20)
//   status_id int [not null]
//   created_at TIMESTAMP [default: `now()`]
//   merged_at TIMESTAMP
// }

// Table statuses {
//   id serial pk
//   status varchar(20)
// }

// Ref pull_requests_statuses: pull_requests.status_id > statuses.id


// Table pr_members {
//   pr_id int [not null]
//   member_id int [not null]
// }

// Ref members_pull_requests: pr_members.member_id < members.id
// Ref pull_requests_members: pull_requests.id > pr_members.pr_id


Table members {
  id serial pk
  uuid uuid [not null]
  name varchar(100)
  is_active bool [default: true]
}

Table teams {
  id serial pk
  name varchar(100)
}

Table members_teams {
  team_id int [not null]
  member_id int [not null]

  indexes {
    (team_id, member_id) [pk]
  }
}

Ref members_teams_member: members_teams.member_id > members.id
Ref members_teams_team: members_teams.team_id > teams.id


Table pull_requests {
  id serial pk
  uuid uuid [not null]
  title varchar(255) [not null]
  status_id int [not null]
  created_at TIMESTAMPZ [not null, default: `now()`]
  merged_at TIMESTAMPZ [null]
  version int  [not null, default: 1] // optimistic locking
}

Table statuses {
  id serial pk
  status varchar(20) [unique, not null]
}

Ref pull_request_status: pull_requests.status_id > statuses.id


Table roles {
  id serial pk
  role varchar(20) // 'author', 'reviewer', 'approver', ...
}

Table pr_members {
  pr_id int [not null]
  member_id int [not null]
  role_id int [not null]
  assigned_at TIMESTAMPZ [not null, default: `now()`]

  indexes {
    (pr_id, member_id) [pk]
  }
}

Ref pr_members_pr: pr_members.pr_id > pull_requests.id
Ref pr_members_member: pr_members.member_id > members.id
Ref pr_members_role: pr_members.role_id > roles.id
